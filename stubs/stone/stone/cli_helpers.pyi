from _typeshed import Incomplete
from abc import ABCMeta, abstractmethod

class FilterExprLexer:
    tokens: tuple[str, ...]
    t_LPAR: str
    t_RPAR: str
    t_NEQ: str
    t_EQ: str
    t_ignore: str
    KEYWORDS: Incomplete
    lexer: Incomplete
    errors: Incomplete
    def __init__(self, debug: bool = False) -> None: ...
    def get_yacc_compat_lexer(self): ...
    def t_BOOLEAN(self, token): ...
    def t_NULL(self, token): ...
    def t_FLOAT(self, token): ...
    def t_INTEGER(self, token): ...
    def t_STRING(self, token): ...
    def t_ID(self, token): ...
    def t_error(self, token) -> None: ...
    def test(self, data) -> None: ...

class FilterExprParser:
    tokens: Incomplete
    start: Incomplete
    precedence: Incomplete
    debug: Incomplete
    yacc: Incomplete
    lexer: Incomplete
    errors: Incomplete
    def __init__(self, debug: bool = False) -> None: ...
    def parse(self, data): ...
    def p_expr(self, p) -> None: ...
    def p_expr_parens(self, p) -> None: ...
    def p_expr_group(self, p) -> None: ...
    def p_pred(self, p) -> None: ...
    def p_op(self, p) -> None: ...
    def p_primitive(self, p) -> None: ...
    def p_error(self, token) -> None: ...

class FilterExpr:
    __metaclass__: type[ABCMeta]
    @abstractmethod
    def eval(self, route): ...

class FilterExprConjunction:
    conj: Incomplete
    lhs: Incomplete
    rhs: Incomplete
    def __init__(self, conj, lhs, rhs) -> None: ...
    def eval(self, route): ...

class FilterExprPredicate:
    op: Incomplete
    lhs: Incomplete
    rhs: Incomplete
    def __init__(self, op, lhs, rhs) -> None: ...
    def eval(self, route): ...

def parse_route_attr_filter(route_attr_filter, debug: bool = False): ...
